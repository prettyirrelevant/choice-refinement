{"version":3,"sources":["store/appSlice.ts","store/reducers.ts","store/stores.js","App.tsx","index.tsx","store/walletSlice.ts","utils/api.ts"],"names":["initialState","darkTheme","localStorage","getItem","modalMenu","openModal","modalType","electModal","openElectModal","modalData","voteModal","openModalVote","voteData","rootReducer","combineReducers","status","state","action","type","payload","wallet","walletReducer","store","configureStore","reducer","preloadedState","middleware","getDefaultMiddleware","serializableCheck","MainPage","loadable","PopFromBottomModal","OverlayElectionModal","App","queryClient","QueryClient","fallback","stores","client","ReactDOM","render","StrictMode","document","getElementById","ChainType","chain","TestNet","walletType","accounts","address","assets","connected","connector","fetching","getAccountAssets","createAsyncThunk","accountData","a","response","apiGetAccountAssets","walletSlice","createSlice","name","reducers","setFetching","console","log","setWalletType","switchChain","reset","setConnector","setConnected","setAccounts","setAccountAssets","killSession","caseReducers","extraReducers","builder","addCase","fulfilled","selectConnector","selectAddress","selectAssets","selectChain","selectConnected","selectWalletType","actions","mainNetClient","algosdk","Algodv2","testNetClient","mainNetIndexer","Indexer","testNetIndexer","clientForChain","MainNet","Error","indexerForChain","accountInformation","setIntDecoding","IntDecoding","BIGINT","do","accountInfo","algoBalance","amount","assetsFromRes","map","id","creator","frozen","Number","decimals","sort","b","Promise","all","asset","getAssetByID","params","unitName","url","unshift","apiGetTxnParams","getTransactionParams"],"mappings":"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","file":"static/js/main.8fef9362.chunk.js","sourcesContent":["export interface AppState {\n  darkTheme: boolean,\n  modalMenu: { openModal: boolean, modalType: string },\n  electModal: { openElectModal: boolean, modalData: [] | null },\n  voteModal: { openModalVote: boolean, voteData: [] | null },\n}\n\nconst initialState = {\n  darkTheme: localStorage.getItem(\"mode\") === \"light\" ? false : true,\n  modalMenu: { openModal: false, modalType: \"menu\" },\n  electModal: { openElectModal: false, modalData: null },\n  voteModal: { openModalVote: false, voteData: null },\n} as AppState;\n\nexport default function appSlice(state = initialState, action: {type: string, payload: any}) {\n  switch (action.type) {\n    case \"light_mode\":\n      return { ...state, darkTheme: false };\n    case \"dark_mode\":\n      return { ...state, darkTheme: true };\n\n    case \"modal_menu\":\n      return { ...state, modalMenu: { openModal: true, modalType: \"menu\" } };\n    case \"modal_connect\":\n      return {\n        ...state,\n        modalMenu: { openModal: true, modalType: \"connectWallet\" },\n      };\n\n    case \"modal_connect_vote\":\n      return {\n        ...state,\n        voteModal: { openModalVote: true, voteData: action.payload },\n      };\n    case \"close_vote_modal\":\n      return { ...state, voteModal: { openModalVote: false, voteData: null } };\n\n    case \"close_modal\":\n      return { ...state, modalMenu: { openModal: false, modalType: \"menu\" } };\n\n    case \"popupElection\":\n      return {\n        ...state,\n        electModal: { openElectModal: true, modalData: action.payload },\n      };\n    case \"closePopupElection\":\n      return {\n        ...state,\n        electModal: { openElectModal: false, modalData: null },\n      };\n\n    default:\n      return state;\n  }\n}","import { combineReducers } from \"redux\";\nimport appReducer, { AppState } from './appSlice';\nimport walletReducer, { WalletState } from './walletSlice';\n\nexport interface State {\n  status: AppState,\n  wallet: WalletState,\n}\n\nconst rootReducer = combineReducers<State>({ status: appReducer, wallet: walletReducer });\nexport default rootReducer;","import { configureStore } from '@reduxjs/toolkit'\nimport rootReducer from \"./reducers\";\n\nlet initialState = {};\n\nconst store = configureStore({\n  reducer: rootReducer,\n  preloadedState: initialState,\n  middleware: (getDefaultMiddleware) => \n    getDefaultMiddleware({\n      serializableCheck: false,\n    })\n});\nexport default store;\n","import { Suspense } from \"react\";\nimport stores from \"./store/stores\";\nimport loadable from \"@loadable/component\";\nimport { Provider as ReduxProvider } from \"react-redux\";\nimport { BrowserRouter as Router } from \"react-router-dom\";\nimport { QueryClient, QueryClientProvider } from \"react-query\";\n\nconst MainPage = loadable(() => import(\"./MainPage\"));\nconst PopFromBottomModal = loadable(\n  () => import(\"./statics/PopFromBottomModal\")\n);\nconst OverlayElectionModal = loadable(\n  () => import(\"./statics/OverlayElectionModal\")\n);\n\nconst renderLoader = () => <p></p>;\n\nconst App = () => {\n  const queryClient = new QueryClient();\n\n  return (\n    <Suspense fallback={renderLoader()}>\n      <ReduxProvider store={stores}>\n        <QueryClientProvider client={queryClient}>\n          <Router>\n            <MainPage />\n            <OverlayElectionModal />\n            <PopFromBottomModal />\n          </Router>\n        </QueryClientProvider>\n      </ReduxProvider>\n    </Suspense>\n  );\n};\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n","\nimport { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport WalletConnect from \"@walletconnect/client\";\nimport { apiGetAccountAssets } from \"../utils/api\";\nimport { State } from \"./reducers\";\n\nexport enum ChainType {\n  MainNet = \"MainNet\",\n  TestNet = \"TestNet\",\n}\n\nexport interface IAssetData {\n  id: number;\n  amount: bigint;\n  creator: string;\n  frozen: boolean;\n  decimals: number;\n  name?: string;\n  unitName?: string;\n  url?: string;\n}\n\nexport interface WalletState {\n  chain: ChainType,\n  walletType: string,\n  accounts: string[],\n  address: string,\n  assets: IAssetData[],\n  connected: boolean,\n  connector: any,\n  fetching: boolean,\n}\n\nconst initialState = {\n  chain: ChainType.TestNet,\n  walletType: \"\",\n  accounts: [],\n  address: \"\",\n  assets: [],\n  connected: false,\n  connector: null,\n  fetching: false,\n} as WalletState;\n\nexport const getAccountAssets = createAsyncThunk(\"walletConnect/getAccountAssets\", async (accountData: {chain: ChainType, address: string}) => {\n  const { chain, address } = accountData;\n  const response = apiGetAccountAssets(chain, address)\n  return response;\n})\n\nexport const walletSlice = createSlice({\n    name: 'wallet',\n    initialState,\n    reducers: {\n      setFetching(state, action) {\n        console.log(\"setFetching: \", action.payload)\n        state.fetching = action.payload;\n      },\n      setWalletType(state, action) {\n        state.walletType = action.payload;\n      },\n      switchChain(state, action) {\n        console.log(\"switchChain chain: \", action.payload)\n        state.chain = action.payload;\n      },\n      reset: (state) => {\n        state.accounts = [];\n        state.address = \"\";\n        state.assets = [];\n        state.connected = false;\n        state.connector = null;\n        state.walletType = \"\";\n      },\n      setConnector: (state, action) => {\n        state.connector = action.payload;\n      },\n      setConnected: (state, action) => {\n        state.connected = action.payload;\n      },\n      setAccounts: (state, action) => {\n        state.accounts = action.payload;\n        if (state.walletType === \"walletConnect\") {\n          state.address = action.payload[0];\n        } else if (state.walletType === \"myAlgo\" || state.walletType === \"algoSigner\") {\n          state.address = action.payload[0].address;\n        }\n      },\n      setAccountAssets: (state, action) => {\n        state.assets = action.payload;\n      },\n      killSession: state => {\n        if (state.connected) {\n          if (state.walletType === \"walletConnect\") {\n            (state.connector as WalletConnect).killSession();\n          }\n          walletSlice.caseReducers.reset(state);\n        }\n      }\n    },\n    extraReducers(builder) {\n      builder.addCase(getAccountAssets.fulfilled, (state, action) => {\n        state.assets = action.payload;\n      })\n    }\n});\n\nexport const selectConnector = (state: State) => state.wallet.connector;\nexport const selectAddress = (state: State) => state.wallet.address;\nexport const selectAssets = (state: State) => state.wallet.assets;\nexport const selectChain = (state: State) => state.wallet.chain;\nexport const selectConnected = (state: State) => state.wallet.connected;\nexport const selectWalletType = (state: State) => state.wallet.walletType;\n\nexport const {\n  setFetching,\n  switchChain,\n  reset,\n  setWalletType,\n  setConnector,\n  setConnected,\n  setAccounts,\n  killSession\n} = walletSlice.actions;\n\nexport default walletSlice.reducer;\n","import algosdk from \"algosdk\";\nimport { IAssetData } from \"../store/walletSlice\";\n\nexport enum ChainType {\n  MainNet = \"MainNet\",\n  TestNet = \"TestNet\",\n}\n\nconst mainNetClient = new algosdk.Algodv2(\"\", \"https://algoexplorerapi.io\", \"\");\nconst testNetClient = new algosdk.Algodv2(\"\", \"https://testnet.algoexplorerapi.io\", \"\");\nconst mainNetIndexer = new algosdk.Indexer(\"\", \"https://algoexplorerapi.io/idx2\", \"\");\nconst testNetIndexer = new algosdk.Indexer(\"\", \"https://testnet.algoexplorerapi.io/idx2\", \"\");\n\nexport function clientForChain(chain: ChainType): algosdk.Algodv2 {\n  switch (chain) {\n    case ChainType.MainNet:\n      return mainNetClient;\n    case ChainType.TestNet:\n      return testNetClient;\n    default:\n      throw new Error(`Unknown chain type: ${chain}`);\n  }\n}\n\nexport function indexerForChain(chain: ChainType): algosdk.Indexer {\n  switch (chain) {\n    case ChainType.MainNet:\n      return mainNetIndexer;\n    case ChainType.TestNet:\n      return testNetIndexer;\n    default:\n      throw new Error(`Unknown chain type: ${chain}`);\n  }\n}\n\nexport async function apiGetAccountAssets(\n  chain: ChainType,\n  address: string,\n): Promise<IAssetData[]> {\n  const client = clientForChain(chain);\n\n  const accountInfo = await client\n    .accountInformation(address)\n    .setIntDecoding(algosdk.IntDecoding.BIGINT)\n    .do();\n\n  const algoBalance = accountInfo.amount as bigint;\n  const assetsFromRes: Array<{\n    \"asset-id\": bigint;\n    amount: bigint;\n    creator: string;\n    frozen: boolean;\n  }> = accountInfo.assets;\n\n  const assets: IAssetData[] = assetsFromRes.map(({ \"asset-id\": id, amount, creator, frozen }) => ({\n    id: Number(id),\n    amount,\n    creator,\n    frozen,\n    decimals: 0,\n  }));\n\n  assets.sort((a, b) => a.id - b.id);\n\n  await Promise.all(\n    assets.map(async asset => {\n      const { params } = await client.getAssetByID(asset.id).do();\n      asset.name = params.name;\n      asset.unitName = params[\"unit-name\"];\n      asset.url = params.url;\n      asset.decimals = params.decimals;\n    }),\n  );\n\n  assets.unshift({\n    id: 0,\n    amount: algoBalance,\n    creator: \"\",\n    frozen: false,\n    decimals: 6,\n    name: \"Algo\",\n    unitName: \"Algo\",\n  });\n\n  return assets;\n}\n\nexport async function apiGetTxnParams(chain: ChainType): Promise<algosdk.SuggestedParams> {\n  const params = await clientForChain(chain)\n    .getTransactionParams()\n    .do();\n  return params;\n}\n\nexport async function apiSubmitTransactions(\n  chain: ChainType,\n  stxns: Uint8Array[],\n): Promise<number> {\n  const { txId } = await clientForChain(chain)\n    .sendRawTransaction(stxns)\n    .do();\n  return await waitForTransaction(chain, txId);\n}\n\nasync function waitForTransaction(chain: ChainType, txId: string): Promise<number> {\n  const client = clientForChain(chain);\n\n  let lastStatus = await client.status().do();\n  let lastRound = lastStatus[\"last-round\"];\n  while (true) {\n    const status = await client.pendingTransactionInformation(txId).do();\n    if (status[\"pool-error\"]) {\n      throw new Error(`Transaction Pool Error: ${status[\"pool-error\"]}`);\n    }\n    if (status[\"confirmed-round\"]) {\n      return status[\"confirmed-round\"];\n    }\n    lastStatus = await client.statusAfterBlock(lastRound + 1).do();\n    lastRound = lastStatus[\"last-round\"];\n  }\n}\n"],"sourceRoot":""}